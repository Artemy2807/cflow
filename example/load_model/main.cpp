#include "model.hpp"

// Пространство имён для использования нейронной сети
using namespace tf;
// Пространство имён для OpenCV
using namespace cv;

int main() {
    // Создаём класс для работы с нейронной сетью
    Model model;
    // Загружаем нейронную сеть из файла
    // Пока загружать модель нейронной сети можно ТОЛЬКО в формате .pb
    // "model.pb" - путь до файла нейронной сети
    // Нейронная сеть из примера обучена на распознавание 3 классов:
    // Ограничение скорости 20 км/ч, ограничение скорости 30 км/ч, ограничение скорости 50 км/ч
    model.load("model.pb");
    // Загружаем картинку из файла
    // "image.jpg" - путь до файла картинки
    // Эта картинка знака ограничения скорости 20 км/ч
    Mat img = imread("img_20.jpg");
    // Структура с информацией о том как обработать загруженное изображение 
    // перед загрузкой в нейронную сеть
    mat_info info;
    // В каком пространстве цветов будет входное изображение
    // OpenCV загружает изображение в пространстве цветов BGR
    info.type = NONE;   // пространство цветов не изменяется
    // Также возможны варианты:
    // RGB - переводим в RGB пространство,
    // GRAY - переводим в чёрно-белое изображение
    // Размер входных данных
    // 1 параметром передаётся ширина входного изображения
    // 2 параметром передаётся высота входного изображения
    info.size = std::make_pair(48, 48);
    // В каком диапазоне находится цвет пикселя входного изображения
    info.range = BINARIZE;  // значение пикселя может принимать диапазон от 0 до 1,
    // также возможны промежуточные значения, например 0.5
    // Также возможны варианты:
    // STANDART - значение пикселя может принимать диапазон от 0 до 255
    // Запускаем нейронную сеть
    // output - ответы нейронной сети
    // img - входное изображение
    // info - структура с информацией о том как обработать входное изображение перед загрузкой в нейронную сеть
    std::vector<float> output = model.predict(img, info);
    // Выводим ответы нейронной сети
    printf("Answer:\n");
    for(size_t i = 0; i < output.size(); i++)
        printf("[%ld]: %f\n", i, output[i]);
    // Далее используйте массив output для своих целей.
    return 0;
}
